function initMap() {
  // Single-world bounds to prevent duplicated Australia / wrapping
  const worldBounds = [[-90, -180], [90, 180]];

  // Create map once (no wrapping, strict bounds)
  map = L.map("map", {
    zoomControl: false,
    attributionControl: true,
    minZoom: 2,
    maxBounds: worldBounds,
    maxBoundsViscosity: 1.0,
    worldCopyJump: false // disable map wrapping across the date line
  }).setView([20, 10], 2);

  // standard zoom control
  L.control.zoom({ position: "topleft" }).addTo(map);

  // Esri World Light Gray canvas â€” crucial: noWrap:true + bounds to stop repeats
  L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}",
    {
      maxZoom: 19,
      noWrap: true,        // stop tiles from repeating horizontally
      bounds: worldBounds, // enforce strict tile bounds
      attribution: 'Tiles &copy; Esri &mdash; Esri, USGS, NOAA'
    }
  ).addTo(map);

  // Keep your existing clustering layers (unchanged logic)
  assetsClusterGroup = L.markerClusterGroup({
    chunkedLoading: true,
    spiderfyOnMaxZoom: true,
    showCoverageOnHover: false,
    disableClusteringAtZoom: 10
  });
  map.addLayer(assetsClusterGroup);

  incidentClusterGroup = L.markerClusterGroup({
    chunkedLoading: true,
    spiderfyOnMaxZoom: true,
    showCoverageOnHover: false,
    disableClusteringAtZoom: 13,
    maxClusterRadius: 50,
    zoomToBoundsOnClick: !isTouch,
    iconCreateFunction: function(cluster) {
      const children = cluster.getAllChildMarkers();
      let count = children.length, maxSeverity = 0;
      let counts = { critical:0, high:0, medium:0, low:0 };
      children.forEach(m => {
        const s = Number(m.options.severity || 1);
        if (s >= 5) { counts.critical++; maxSeverity = Math.max(maxSeverity,5); }
        else if (s >= 4) { counts.high++; maxSeverity = Math.max(maxSeverity,4); }
        else if (s === 3) { counts.medium++; maxSeverity = Math.max(maxSeverity,3); }
        else { counts.low++; }
      });
      let cls = 'cluster-blue';
      if (counts.critical + counts.high > 0) cls = (counts.critical > 0) ? 'cluster-red' : 'cluster-amber';
      if (maxSeverity >= 4) cls = 'cluster-red'; else if (maxSeverity === 3) cls = 'cluster-amber';
      const ariaLabel = escapeAttr(`Cluster of ${count} incidents. ${counts.critical} Critical, ${counts.high} High, ${counts.medium} Medium, ${counts.low} Low.`);
      const html = `<div class="cluster-icon ${cls}" tabindex="0" role="button" aria-label="${ariaLabel}" title="${ariaLabel}" style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;"><div class="cluster-count" aria-hidden="true" tabindex="-1">${count}</div></div>`;
      return L.divIcon({ html, className: '', iconSize: [40,40], iconAnchor: [20,20] });
    }
  });

  // cluster hover/click UX (keeps existing behavior)
  incidentClusterGroup.on('clustermouseover', (e) => {
    clearTimeout(_clusterHoverTimeout);
    _clusterHoverTimeout = setTimeout(() => {
      const cluster = e.layer;
      const children = cluster.getAllChildMarkers();
      let counts = { critical:0, high:0, medium:0, low:0 };
      children.forEach(m => {
        const s = Number(m.options.severity || 1);
        if (s >= 5) counts.critical++; else if (s >= 4) counts.high++; else if (s === 3) counts.medium++; else counts.low++;
      });
      const summary = `<b>Cluster: ${children.length} Incidents</b><br/>` +
                      (counts.critical ? `<span style="color:#d93025">Critical: ${counts.critical}</span><br/>` : '') +
                      (counts.high ? `<span style="color:#d93025">High: ${counts.high}</span><br/>` : '') +
                      (counts.medium ? `<span style="color:#f9ab00">Medium: ${counts.medium}</span><br/>` : '') +
                      (counts.low ? `<span style="color:#1a73e8">Low: ${counts.low}</span>` : '');
      L.popup({ closeButton: false, offset: [0, -10], className: 'map-tooltip' }).setLatLng(cluster.getLatLng()).setContent(summary).openOn(map);
    }, 80);
  });
  incidentClusterGroup.on('clustermouseout', () => { clearTimeout(_clusterHoverTimeout); map.closePopup(); });
  incidentClusterGroup.on('clusterclick', (e) => {
    if (incidentClusterGroup.options.zoomToBoundsOnClick) return;
    const cluster = e.layer, children = cluster.getAllChildMarkers();
    L.popup({ closeButton: true, offset: [0, -10], className: 'map-tooltip' }).setLatLng(cluster.getLatLng()).setContent(`<b>Cluster: ${children.length} Items</b><br/>Zoom in to see details.`).openOn(map);
    setTimeout(() => document.querySelector('.leaflet-popup-close-button')?.focus(), 50);
  });

  map.addLayer(incidentClusterGroup);

  // critical layer (always on top)
  criticalLayerGroup = L.layerGroup().addTo(map);
  try { criticalLayerGroup.bringToFront(); } catch(e) {}

  // render assets and ensure map invalidation
  renderAssetsOnMap("Global");
  setTimeout(()=>{ try { map.invalidateSize(); } catch(e){} }, 200);
  window.addEventListener('resize', ()=>{ try { map.invalidateSize(); } catch(e){} });
}
