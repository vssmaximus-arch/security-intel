// FIX: MAP (SWITCHED TO ESRI WORLD GRAY CANVAS + CLUSTERING)
  function initMap() {
    // 1. DEFINE HARD BOUNDARIES (The "Walls")
    // This defines a box from the South Pole/Date Line to North Pole/Date Line
    const southWest = L.latLng(-89.9, -180);
    const northEast = L.latLng(89.9, 180);
    const worldBounds = L.latLngBounds(southWest, northEast);
    
    map = L.map("map", {
      scrollWheelZoom: false,
      zoomControl: false,
      attributionControl: true,
      minZoom: 2,              // Stop zooming out so far that the world repeats
      maxBounds: worldBounds,  // Apply the "Walls"
      maxBoundsViscosity: 1.0, // 1.0 = "Concrete Wall" (bounces back instantly)
      worldCopyJump: false     // DONT jump the user to the "other" world
    }).setView([25, 10], 2);
    
    L.control.zoom({ position: "topleft" }).addTo(map);
  
    // 2. CONFIGURE TILES TO NOT REPEAT
    L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}",
      { 
        maxZoom: 19, 
        noWrap: true, // CRITICAL: Tells the image not to duplicate horizontally
        bounds: worldBounds,
        attribution: 'Tiles &copy; Esri &mdash; Esri, USGS, NOAA'
      }
    ).addTo(map);
  
    // ... (rest of your marker cluster code remains exactly the same) ...
    // 1. Assets cluster (for Dell sites)
    assetsClusterGroup = L.markerClusterGroup({
      chunkedLoading: true,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      disableClusteringAtZoom: 10
    });
    map.addLayer(assetsClusterGroup);
  
    // 2. Incident clustering
    incidentClusterGroup = L.markerClusterGroup({
      chunkedLoading: true,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      disableClusteringAtZoom: 13,
      maxClusterRadius: 50,
      zoomToBoundsOnClick: !isTouch,
      iconCreateFunction: function(cluster) {
        const children = cluster.getAllChildMarkers();
        let count = children.length;
        let maxSeverity = 0;
        let counts = { critical:0, high:0, medium:0, low:0 };
        children.forEach(m => {
          const s = Number(m.options.severity || 1);
          if (s >= 5) { counts.critical++; maxSeverity = Math.max(maxSeverity,5); }
          else if (s >= 4) { counts.high++; maxSeverity = Math.max(maxSeverity,4); }
          else if (s === 3) { counts.medium++; maxSeverity = Math.max(maxSeverity,3); }
          else { counts.low++; }
        });
  
        let cls = 'cluster-blue';
        if (counts.critical + counts.high > 0) cls = (counts.critical > 0) ? 'cluster-red' : 'cluster-amber';
        if (maxSeverity >= 4) cls = 'cluster-red'; else if (maxSeverity === 3) cls = 'cluster-amber';
  
        const ariaLabel = escapeAttr(`Cluster of ${count} incidents. ${counts.critical} Critical, ${counts.high} High, ${counts.medium} Medium, ${counts.low} Low.`);
        const html = `<div class="cluster-icon ${cls}" tabindex="0" role="button" aria-label="${ariaLabel}" title="${ariaLabel}" style="width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;"><div class="cluster-count" aria-hidden="true" tabindex="-1">${count}</div></div>`;
  
        return L.divIcon({ html, className: '', iconSize: [40,40], iconAnchor: [20,20] });
      }
    });

    // ... (rest of your event listeners for hover/click remain same) ...
    incidentClusterGroup.on('clustermouseover', (e) => { /* ... */ });
    incidentClusterGroup.on('clustermouseout', () => { /* ... */ });
    incidentClusterGroup.on('clusterclick', (e) => { /* ... */ });

    map.addLayer(incidentClusterGroup);
    criticalLayerGroup = L.layerGroup().addTo(map);
    try { criticalLayerGroup.bringToFront(); } catch(e) {}
    renderAssetsOnMap("Global");
    setTimeout(()=>{ try { map.invalidateSize(); map.fitWorld(); } catch(e){} }, 200);
    window.addEventListener('resize', ()=>{ try { map.invalidateSize(); } catch(e){} });
  }
